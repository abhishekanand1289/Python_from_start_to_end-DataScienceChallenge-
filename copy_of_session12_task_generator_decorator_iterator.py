# -*- coding: utf-8 -*-
"""Copy of session12-task-generator-decorator-iterator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XMON3ftW4sbLoCPjs61RCH19wC_T-aoP

## Namespace and Scope

###`Q1:` Write `Person` Class as given below and then display it's namespace.

```
Class Name - Person

Attributes:
name - public
state - public
city - private
age - private

Methods:
address - public
It give address of the person as "<name>, <city>, <state>"
```
"""

class Person():
  def __init__(self,name,state):
    self.name = name
    self.state = state
    self.__city = None
    self.__age = None

  def set_city(self,city):
    self.__city = city
  def get_city(self):
    return self.__city

  def set_age(self,age):
    self.__age = age
  def get_age(self):
    return self.__age

  def address(self):
    return f"<{self.name}>,<{self.__city}>,<{self.__age}>"

for i in Person.__dict__:
  print(i)

"""###`Q2:` Write a program to show namespace of object/instance of above(Person) class."""

p = Person('ab','ap')

for i in p.__dict__:
  print(i)

"""###`Q3:` Write a recursive program to to calculate `gcd` and print no. of function calls taken to find the solution.
```
gcd(5,10) -> result in 5 as gcd and function call 4
```
"""

count = 0
def gcd(a,b):
  global count
  count += 1
  if a == b:
    return a
  elif a>b:
    return gcd(a-b,b)
  else:
    return gcd(b-a,a)

print(f'GCD is --> {gcd(20,10)} and no. of time function has been called',count)

"""## Itterator And Generator

###`Q4:` Create MyEnumerate class,
Create your own `MyEnumerate` class such that someone can use it instead of enumerate. It will need to return a `tuple` with each iteration, with the first element in the tuple being the `index` (starting with 0) and the second element being the `current element` from the underlying data structure. Trying to use `MyEnumerate` with a noniterable argument will result in an error.

```
for index, letter in MyEnumerate('abc'):
    print(f'{index} : {letter}')
```

Output:
```
0 : a
1 : b
2 : c
```
"""

class MyEnumerate_iterable:

  def __init__(self,data):
    self.data = data

  def __iter__(self):
    return MyEnumerate_iterator(self.data, len(self.data))

class MyEnumerate_iterator:
  def __init__(self, data, max_items):
    self.data = data
    self.max_items = max_items
    self.index = 0
  def __iter__(self):
    return self
  def __next__(self):
    if self.index >= self.max_items:
      raise StopIteration

    value = self.index, self.data[self.index]
    self.index += 1
    return value

for index, letter in MyEnumerate_iterable('abc'):
    print(f'{index} : {letter}')

"""###`Q5:` Iterate in circle
Define a class, `Circle`, that takes two arguments when defined: a sequence and a number. The idea is that the object will then return elements the defined number of times. If the number is greater than the number of elements, then the sequence  repeats as necessary. You can define an another class used as a helper (like I call `CircleIterator`).

```
c = Circle('abc', 5)
d = Circle('abc', 7)
print(list(c))
print(list(d))
```

Output
```
[a, b, c, a, b]
[a, b, c, a, b, c, a]
```
"""

class Circle:

  def __init__(self,seq,num):
    self.seq = seq
    self.num = num

  def __iter__(self):
    return CircleIterator(self.seq,self.num)

class CircleIterator:

  def __init__(self, seq, num):
    self.seq = seq
    self.num = num
    self.index = 0

  def __iter__(self):
    return self

  def __next__(self):
    if self.index >= self.num:
      raise StopIteration

    value = self.seq[self.index % len(self.seq)]
    self.index += 1
    return value

c = Circle('abc', 5)
d = Circle('abc', 7)
print(list(c))
print(list(d))

"""###`Q6:` Generator time elapsed
Write a generator function whose argument must be iterable. With each iteration, the generator will return a two-element tuple. The first element in the tuple will be an integer indicating how many seconds have passed since the previous iteration. The tupleâ€™s second element will be the next item from the passed argument.

Note that the timing should be relative to the previous iteration, not when the
generator was first created or invoked. Thus the timing number in the first iteration
will be 0

```
for t in elapsed_since('abcd'):
    print(t)
    time.sleep(2)
```

Output:
```
(0.0, 'a')
(2.005651817999933, 'b')
(2.0023095009998997, 'c')
(2.001949742000079, 'd')
```
Note: Your output may differ because of diffrent system has different processing configuration.
"""

import time
def elapsed_since(x):
  prev_it = time.perf_counter()
  for i in x:
    now = time.perf_counter()
    it_time = now - prev_it
    prev_it = now
    yield (it_time,i)

for t in elapsed_since('abcd'):
    print(t)
    time.sleep(2)

"""## Decorators

###`Q7:` Write a Python program to make a chain of function decorators (bold, italic, underline etc.) on a given function which prints "hello world"

```
def hello():
    return "hello world"
```

```
bold - wrap string with <b> tag. <b>Str</b>
italic - wrap string with <i> tag. <i>Str</i>
underline- wrap string with <u> tag. <u>Str</u>
```
"""

def bold(func):
  def wrapper():
    print(f"<b>{func()}</b>")
  return wrapper

def italic(func):
  def wrapper():
    print(f"<i>{func()}</i>")
  return wrapper

def underline(func):
  def wrapper():
    print(f"<u>{func()}</u>")
  return wrapper

@underline
def hello():
  return 'Hello World'

@bold
def hello1():
  return 'Hello World'

@italic
def hello2():
  return 'Hello World'

hello()
hello1()
hello2()

"""###`Q8:` Write a decorator called `printer` which causes any decorated function to print their return values. If the return value of a given function is `None`, printer should do nothing.


"""

def printer(func):
  def wrapper(*args):
    val = func(*args)
    if val is not None:
      print(val)
  return wrapper

@printer
def alpha():
  return 'Hello man!!!'

@printer
def beta():
  return


alpha()
print("######")
beta()
print('######')

"""###`Q9:` Make a decorator which calls a given function twice. You can assume the functions don't return anything important, but they may take arguments.
```
#Lets say given function
def hello(string):
    print(string)

#on calling after specified decorator is inplaced
hello('hello')
```

Output:
```
hello
hello
```
"""

def twice_dec(func):
  def wrapper(*args):
    func(*args)
    func(*args)
  return wrapper

@twice_dec
def hello(string):
  print(string)

hello('Hello! Bhai ela unnav')

"""### `Q10:` Write a decorator which doubles the return value of any function. And test that decoratos is working correctly or not using `asert`.

```
add(2,3) -> result in 10. Without decorator it should be 5.
```
"""

def twice_dec(func):
  def wrapper(*args):
    result = func(*args)*2
    return result
  return wrapper

@twice_dec
def add(a,b):
  return a+b

def add_test(a,b):
  return a+b

a = 2
b = 3

assert add_test(a,b)*2 == add(a,b), "Values doesn't match"
print("Values are matching")

