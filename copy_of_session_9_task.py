# -*- coding: utf-8 -*-
"""Copy of session-9-task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZvmZQBB0sVQvxA4_jhDFgZBfjCBdY2DU

### `Problem-1:` Class inheritence

Create a **Bus** child class that inherits from the Vehicle class. The default fare charge of any vehicle is seating capacity * 100. If Vehicle is Bus instance, we need to add an extra 10% on full fare as a maintenance charge. So total fare for bus instance will become the final amount = total fare + 10% of the total fare.

Note: The bus seating capacity is 50. so the final fare amount should be 5500. You need to override the fare() method of a Vehicle class in Bus class.
"""

class Vehicle:

  def __init__(self,seating_capacity):
    self.seating_capacity = seating_capacity

  def fare(self):
    return self.seating_capacity * 100

class Bus(Vehicle):

  def fare(self):
    total_fare = super().fare()
    return total_fare + 0.1 * (total_fare)

b = Bus(50)
b.fare()

"""### `Problem-2:` Class Inheritence

Create a Bus class that inherits from the Vehicle class. Give the capacity argument of *Bus.seating_capacity()* a default value of 50.

Use the following code for your parent Vehicle class.
"""

class Vehicle:

  def __init__(self,seating_capacity = 50):
    self.seating_capacity = seating_capacity

  def fare(self):
    return self.seating_capacity * 100

class Bus(Vehicle):

  def fare(self):
    total_fare = super().fare()
    return total_fare + 0.1 * (total_fare)

b = Bus()
b.fare()



"""### `Problem-3:` Write a program that has a class Point. Define another class Location which has two objects (Location & Destination) of class Point. Also define a function in Location that prints the reflection of Destination on the x axis."""

class Point:

  def __init__(self,x,y):
    self.x = x
    self.y = y

  def show_points(self):
    return f"{self.x},{self.y}"

class Location:

  def __init__(self,x1,y1,x2,y2):
    self.location = Point(x1,y1)
    self.destination = Point(x2,y2)

  def reflection(self):
    self.destination.y = -self.destination.y
    print("reflection: ", self.destination.show_points())


l = Location(2,8,3,9)
l.reflection()

"""### `Problem-4:` Write a program that has an abstract class Polygon. Derive two classes Rectangle and Triamgle from Polygon and write methods to get the details of their dimensions and hence calculate the area."""

from abc import ABC, abstractmethod

class Polygon(ABC):

  @abstractmethod
  def dimensions(self):
    pass


  @abstractmethod
  def area(self):
    pass

class Rectangle(Polygon):

  def dimensions(self,l,b):
    self.length = l
    self.breadth = b

  def area(self):
    return self.length * self.breadth

class Triangle(Polygon):

  def dimensions(self,b,h):
    self.base = b
    self.height = h

  def area(self):
    return 0.5 * self.base * self.height

r = Rectangle()
t = Triangle()
r.dimensions(2,10)
t.dimensions(20,50)
print(r.area())
print(t.area())

"""### `Problem-5:` Write a program with class Bill. The users have the option to pay the bill either by cheque or by cash. Use the inheritance to model this situation."""

class Bill:

  def __init__(self,item,price):
    self.item = item
    self.price = price
    self.total = 0
    for i in self.price:
      self.total = self.total + i

  def display(self):
    print("Items Ordered:            Item Price:")
    for i in range(len(self.item)):
      print(self.item[i],"                      ", self.price[i])

    print("                                      ")

    print("Total Bill:  ",self.total,"/- rupees only")

    print("                                      ")

class Cheque(Bill):

  def __init__(self,item,price,chqno,nob):
    super().__init__(item,price)
    self.cheque_no = chqno
    self.name_of_bank = nob

  def show_cheque(self):
    super().display()
    print("Cheque Number: ", self.cheque_no)
    print("Name of Bank : ",self.name_of_bank)


class Cash(Bill):

  def __init__(self,item,price,den,value):
    super().__init__(item,price)
    self.denomination = den
    self.value = value

  def show_cash_payment(self):
    super().display()
    print("Denomination:             Value:")
    payment = 0
    for i in range(len(self.denomination)):
      print(self.denomination[i],"                      ", self.value[i])
      payment = payment + (self.denomination[i]*self.value[i])
    print("                                      ")
    print("Total Paid: ",payment,"/-")
    print("Balance:    ",payment-self.total,"/-")




l = ["Dosa","Idly","Poori","Vada"]
p = [20,20,40,15]
d = [10, 50]
v = [5, 1]
c = 135489
b = 'SBI'

cheque = Cheque(l,p,c,b)
cash = Cash(l,p,d,v)
print(cash.show_cash_payment())
print(cheque.show_cheque())

"""###`Q-6:` FlexibleDict
As of now we are accessing values from dictionary with exact keys. Now we want to amend accessing values functionality. if a dict have key `1` (int) the even if we try to access values by giving `'1'` (1 as str) as key, we should get the same result and vice versa.

Write a class `FlexibleDict` upon builtin `dict` class with above required functionality.

Hint- `dict[key] => dict.__getitem__(key)`

Ex.
```
fd = FlexibleDict()
fd['a'] = 100
print(fd['a']) # Like regular dict

fd[5] = 500
print(fd[5]) # Like regular dict

fd[1] = 100
print(fd['1']) # actual Key is int but still trying to access through str key.
fd['1'] = 100
print(fd[1])

```
`Output:`
```
100
500
100
100

```
"""





